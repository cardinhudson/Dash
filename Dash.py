# %%
import streamlit as st
import pandas as pd
import os
import altair as alt
import plotly.graph_objects as go
from auth_simple import (verificar_autenticacao, exibir_header_usuario,
                         eh_administrador, verificar_status_aprovado,
                         get_usuarios_cloud, adicionar_usuario_simples, criar_hash_senha)
from datetime import datetime

# Configura√ß√£o otimizada da p√°gina para melhor performance
st.set_page_config(
    page_title="Dashboard KE5Z",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Configura√ß√µes para otimizar conex√£o e performance
if 'connection_optimized' not in st.session_state:
    # Configurar pandas para usar menos mem√≥ria
    pd.set_option('display.max_columns', 50)
    pd.set_option('display.max_rows', 1000)
    
    # Marcar como otimizado
    st.session_state.connection_optimized = True

# Verificar autentica√ß√£o - OBRIGAT√ìRIO no in√≠cio de cada p√°gina
verificar_autenticacao()

# Verificar se o usu√°rio est√° aprovado
if 'usuario_nome' in st.session_state and not verificar_status_aprovado(st.session_state.usuario_nome):
    st.warning("‚è≥ Sua conta ainda est√° pendente de aprova√ß√£o. "
               "Aguarde o administrador aprovar seu acesso.")
    st.info("üìß Voc√™ receber√° uma notifica√ß√£o quando sua conta for "
            "aprovada.")
    st.stop()

# Detectar se estamos no Streamlit Cloud
try:
    base_url = st.get_option('server.baseUrlPath') or ''
    is_cloud = 'share.streamlit.io' in base_url
except Exception:
    is_cloud = False

# Informar sobre ambiente
if is_cloud:
    st.sidebar.info("‚òÅÔ∏è **Modo Cloud**\n"
                     "Algumas funcionalidades s√£o limitadas no Streamlit Cloud.")
else:
    st.sidebar.success("üíª **Modo Local**\n"
                       "Todas as funcionalidades dispon√≠veis.")

# Sistema de cache inteligente para otimiza√ß√£o de mem√≥ria e conex√£o
@st.cache_data(
    ttl=3600,
    max_entries=1,
    show_spinner=True,
    persist="disk"
)
def load_data_optimized():
    """Carrega dados com otimiza√ß√£o inteligente de mem√≥ria"""
    arquivo_parquet = os.path.join("KE5Z", "KE5Z.parquet")
    
    try:
        if not os.path.exists(arquivo_parquet):
            raise FileNotFoundError(f"Arquivo n√£o encontrado: {arquivo_parquet}")
        
        # Verificar tamanho do arquivo
        file_size_mb = os.path.getsize(arquivo_parquet) / (1024 * 1024)
        
        # Carregar dados
        df = pd.read_parquet(arquivo_parquet)
        
        # Remover amostragem para n√£o afetar gr√°ficos; apenas compactar tipos
        
        # Otimizar tipos de dados para economizar mem√≥ria (sem alterar conte√∫do)
        original_memory = df.memory_usage(deep=True).sum() / (1024 * 1024)
        
        for col in df.columns:
            if df[col].dtype == 'object':
                unique_ratio = df[col].nunique() / len(df)
                if unique_ratio < 0.5:  # Menos de 50% valores √∫nicos
                    df[col] = df[col].astype('category')
        
        # Converter floats para tipos menores
        for col in df.select_dtypes(include=['float64']).columns:
            df[col] = pd.to_numeric(df[col], downcast='float')
        
        # Converter ints para tipos menores
        for col in df.select_dtypes(include=['int64']).columns:
            df[col] = pd.to_numeric(df[col], downcast='integer')
        
        # Calcular economia de mem√≥ria
        optimized_memory = df.memory_usage(deep=True).sum() / (1024 * 1024)
        saved_memory = original_memory - optimized_memory
        
        if saved_memory > 1:  # Economia significativa
            st.sidebar.success(f"üíæ Mem√≥ria economizada: {saved_memory:.1f}MB")
        
        return df
        
    except Exception as e:
        raise e

# Carregar dados
try:
    df_total = load_data_optimized()
    st.sidebar.success("‚úÖ Dados carregados com sucesso")
    
    # Log informativo
    if not is_cloud:
        st.sidebar.info(f"üìä {len(df_total)} registros carregados")
        
except FileNotFoundError:
    st.error("‚ùå Arquivo de dados n√£o encontrado!")
    st.error(f"üîç Procurando por: `KE5Z/KE5Z.parquet`")
    st.info("üí° **Solu√ß√µes:**")
    st.info("1. Verifique se o arquivo `KE5Z.parquet` est√° na pasta `KE5Z/`")
    st.info("2. Execute a extra√ß√£o de dados localmente")
    st.info("3. Fa√ßa commit do arquivo no reposit√≥rio")
    
    if is_cloud:
        st.warning("‚òÅÔ∏è **No Streamlit Cloud:** Certifique-se que o arquivo "
                  "foi enviado para o reposit√≥rio")
    
    st.stop()
    
except Exception as e:
    st.error(f"‚ùå Erro ao carregar dados: {str(e)}")
    st.info("üîß **Poss√≠veis causas:**")
    st.info("‚Ä¢ Arquivo corrompido ou formato inv√°lido")
    st.info("‚Ä¢ Problema de permiss√µes")
    st.info("‚Ä¢ Arquivo muito grande")
    
    if is_cloud:
        st.info("‚òÅÔ∏è **No Cloud:** Verifique se o arquivo tem menos de 100MB")
    
    st.stop()

# Filtrar o df_total com a coluna 'USI' que n√£o seja nula (incluindo 'Others')
df_total = df_total[df_total['USI'].notna()]

# Header com informa√ß√µes do usu√°rio e bot√£o de logout
col1, col2, col3 = st.columns([2, 1, 1])
with col1:
    st.title("üìä Dashboard - Visualiza√ß√£o de Dados TC - KE5Z")
st.subheader("Somente os dados com as contas do Per√≠metro TC")

# Exibir header do usu√°rio
exibir_header_usuario()

st.markdown("---")

# Filtros para o DataFrame
st.sidebar.title("Filtros")

# Cache para op√ß√µes de filtros (otimiza√ß√£o de performance)
@st.cache_data(ttl=1800, max_entries=3)
def get_filter_options(df, column_name):
    """Obt√©m op√ß√µes de filtro com cache para melhor performance"""
    if column_name in df.columns:
        return ["Todos"] + sorted(df[column_name].dropna().astype(str).unique().tolist())
    return ["Todos"]

# Filtro 1: USINA (com cache otimizado)
usina_opcoes = get_filter_options(df_total, 'USI')
default_usina = ["Ve√≠culos"] if "Ve√≠culos" in usina_opcoes else ["Todos"]
usina_selecionada = st.sidebar.multiselect("Selecione a USINA:", usina_opcoes, default=default_usina)

# Filtrar o DataFrame com base na USI
if "Todos" in usina_selecionada or not usina_selecionada:
    df_filtrado = df_total.copy()
else:
    df_filtrado = df_total[df_total['USI'].astype(str).isin(usina_selecionada)]

# Filtro 2: Per√≠odo (com cache otimizado)
periodo_opcoes = get_filter_options(df_filtrado, 'Per√≠odo')
periodo_selecionado = st.sidebar.selectbox("Selecione o Per√≠odo:", periodo_opcoes)
if periodo_selecionado != "Todos":
    df_filtrado = df_filtrado[df_filtrado['Per√≠odo'].astype(str) == str(periodo_selecionado)]

# Filtro 3: Centro cst (com cache otimizado)
if 'Centro cst' in df_filtrado.columns:
    centro_cst_opcoes = get_filter_options(df_filtrado, 'Centro cst')
    centro_cst_selecionado = st.sidebar.selectbox("Selecione o Centro cst:", centro_cst_opcoes)
    if centro_cst_selecionado != "Todos":
        df_filtrado = df_filtrado[df_filtrado['Centro cst'].astype(str) == str(centro_cst_selecionado)]

# Filtro 4: Conta cont√°bil (com cache otimizado)
if 'N¬∫ conta' in df_filtrado.columns:
    conta_contabil_opcoes = get_filter_options(df_filtrado, 'N¬∫ conta')[1:]  # Remove "Todos" para multiselect
    conta_contabil_selecionadas = st.sidebar.multiselect("Selecione a Conta cont√°bil:", conta_contabil_opcoes)
    if conta_contabil_selecionadas:
        df_filtrado = df_filtrado[df_filtrado['N¬∫ conta'].astype(str).isin(conta_contabil_selecionadas)]

# Filtros adicionais (com cache otimizado)
for col_name, label in [("Fornecedor", "Fornecedor"), ("Fornec.", "Fornec."), ("Tipo", "Tipo"), ("Type 05", "Type 05"), ("Type 06", "Type 06"), ("Type 07", "Type 07")]:
    if col_name in df_filtrado.columns:
        opcoes = get_filter_options(df_filtrado, col_name)
        selecionadas = st.sidebar.multiselect(f"Selecione o {label}:", opcoes, default=["Todos"])
        if selecionadas and "Todos" not in selecionadas:
            df_filtrado = df_filtrado[df_filtrado[col_name].astype(str).isin(selecionadas)]

# Exibir o n√∫mero de linhas e colunas do DataFrame filtrado e a soma do valor total
st.sidebar.write(f"N√∫mero de linhas: {df_filtrado.shape[0]}")
st.sidebar.write(f"N√∫mero de colunas: {df_filtrado.shape[1]}")
st.sidebar.write(f"Soma do Valor total: R$ {df_filtrado['Valor'].sum():,.2f}")

# Monitoramento de cache e mem√≥ria
st.sidebar.markdown("---")
st.sidebar.subheader("üíæ Status do Sistema")

# Informa√ß√µes de cache
try:
    import sys
    
    # Tamanho do DataFrame em mem√≥ria
    df_size_mb = sys.getsizeof(df_filtrado) / (1024 * 1024)
    st.sidebar.write(f"**Dados filtrados:** {df_size_mb:.1f}MB")
    
    # Status do cache
    st.sidebar.write(f"**Cache ativo:** ‚úÖ 30min TTL")
    st.sidebar.write(f"**Otimiza√ß√£o:** ‚úÖ Tipos compactados")
    
    # Bot√£o de limpeza de cache
    if st.sidebar.button("üßπ Limpar Cache", help="Limpa cache para liberar mem√≥ria"):
        st.cache_data.clear()
        import gc
        gc.collect()
        st.sidebar.success("‚úÖ Cache limpo!")
        st.rerun()
        
except Exception as e:
    st.sidebar.error(f"Erro no monitoramento: {e}")

# Se√ß√£o administrativa (apenas para admin)
if eh_administrador():
    st.sidebar.markdown("---")
    st.sidebar.subheader("üëë √Årea Administrativa")

    # Carregar usu√°rios do novo sistema
    usuarios = get_usuarios_cloud()

    # Informar sobre limita√ß√µes baseado no ambiente
    if is_cloud:
        st.sidebar.info(
            "‚òÅÔ∏è **Modo Cloud:** Usu√°rios s√£o gerenciados via Streamlit Secrets. "
            "Configure em Settings > Secrets no painel do Streamlit Cloud."
        )
    else:
        st.sidebar.info(
            "üíª **Modo Local:** Sistema de autentica√ß√£o simplificado com "
            "usu√°rios de demonstra√ß√£o."
        )

    # Status atual dos usu√°rios
    total_usuarios = len(usuarios)
    usuarios_aprovados = len([u for u in usuarios.values()
                              if u.get('status') == 'aprovado'])
    usuarios_pendentes = len([u for u in usuarios.values()
                              if u.get('status') == 'pendente'])

    st.sidebar.metric("üë• Total", total_usuarios)
    st.sidebar.metric("‚úÖ Aprovados", usuarios_aprovados)
    st.sidebar.metric("‚è≥ Pendentes", usuarios_pendentes)

    # Listar usu√°rios
    st.sidebar.markdown("---")
    st.sidebar.subheader("üìã Usu√°rios Cadastrados")

    for usuario, dados in usuarios.items():
        tipo_icon = "üëë" if dados.get('tipo') == 'administrador' else "üë•"
        tipo_text = "Admin" if dados.get('tipo') == 'administrador' else "User"
        status_icon = "‚úÖ" if dados.get('status') == 'aprovado' else "‚è≥"
        
        st.sidebar.write(f"{tipo_icon} {status_icon} **{usuario}** - {tipo_text}")

else:
    st.sidebar.markdown("---")
    st.sidebar.info("üîí Apenas o administrador pode gerenciar usu√°rios.")

# Gr√°fico de barras para a soma dos valores por 'Per√≠odo'
@st.cache_data(ttl=900, max_entries=2)
def create_period_chart(df_data):
    """Cria gr√°fico otimizado"""
    try:
        chart_data = df_data.groupby('Per√≠odo')['Valor'].sum().reset_index()
        
        grafico_barras = alt.Chart(chart_data).mark_bar().encode(
            x=alt.X('Per√≠odo:N', title='Per√≠odo'),
            y=alt.Y('Valor:Q', title='Soma do Valor'),
            color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
            tooltip=['Per√≠odo:N', 'Valor:Q']
        ).properties(
            title='Soma do Valor por Per√≠odo'
        )
        
        return grafico_barras
    except Exception as e:
        st.error(f"Erro ao criar gr√°fico: {e}")
        return None

# Criar e exibir gr√°fico
grafico_barras = create_period_chart(df_filtrado)
if grafico_barras:
    # Adicionar r√≥tulos com valores nas barras
    rotulos = grafico_barras.mark_text(
        align='center',
        baseline='middle',
        dy=-10,  # Ajuste vertical
        color='black',
        fontSize=12
    ).encode(
        text=alt.Text('Valor:Q', format=',.2f')
    )
    
    # Combinar gr√°fico com r√≥tulos
    grafico_completo = grafico_barras + rotulos
    st.altair_chart(grafico_completo, use_container_width=True)

# Gr√°ficos adicionais por Type
st.subheader("üìä An√°lise por Categorias")

# Gr√°fico por Type 05
if 'Type 05' in df_filtrado.columns:
    @st.cache_data(ttl=900, max_entries=2)
    def create_type05_chart(df_data):
        try:
            type05_data = df_data.groupby('Type 05')['Valor'].sum().reset_index()
            type05_data = type05_data.sort_values('Valor', ascending=False)
            
            chart = alt.Chart(type05_data).mark_bar().encode(
                x=alt.X('Type 05:N', title='Type 05', sort='-y'),
                y=alt.Y('Valor:Q', title='Soma do Valor'),
                color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
                tooltip=['Type 05:N', 'Valor:Q']
            ).properties(
                title='Soma do Valor por Type 05',
                height=400
            )
            
            return chart
        except Exception as e:
            st.error(f"Erro no gr√°fico Type 05: {e}")
            return None
    
    chart_type05 = create_type05_chart(df_filtrado)
    if chart_type05:
        st.altair_chart(chart_type05, use_container_width=True)

# Gr√°fico por Type 06
if 'Type 06' in df_filtrado.columns:
    @st.cache_data(ttl=900, max_entries=2)
    def create_type06_chart(df_data):
        try:
            type06_data = df_data.groupby('Type 06')['Valor'].sum().reset_index()
            type06_data = type06_data.sort_values('Valor', ascending=False)
            
            chart = alt.Chart(type06_data).mark_bar().encode(
                x=alt.X('Type 06:N', title='Type 06', sort='-y'),
                y=alt.Y('Valor:Q', title='Soma do Valor'),
                color=alt.Color('Valor:Q', title='Valor', scale=alt.Scale(scheme='redyellowgreen', reverse=True)),
                tooltip=['Type 06:N', 'Valor:Q']
            ).properties(
                title='Soma do Valor por Type 06',
                height=400
            )
            
            return chart
        except Exception as e:
            st.error(f"Erro no gr√°fico Type 06: {e}")
            return None
    
    chart_type06 = create_type06_chart(df_filtrado)
    if chart_type06:
        st.altair_chart(chart_type06, use_container_width=True)

# Tabela din√¢mica com cores
df_pivot = df_filtrado.pivot_table(index='USI', columns='Per√≠odo', values='Valor', aggfunc='sum', margins=True, margins_name='Total', fill_value=0)
st.subheader("Tabela Din√¢mica - Soma do Valor por USI e Per√≠odo")

# Aplicar formata√ß√£o com cores (verde para positivo, vermelho para negativo)
def colorir_valores(val):
    if isinstance(val, (int, float)):
        if val < 0:
            return 'color: #e74c3c; font-weight: bold;'  # Vermelho para negativo
        elif val > 0:
            return 'color: #27ae60; font-weight: bold;'  # Verde para positivo
    return ''

styled_pivot = df_pivot.style.format('R$ {:,.2f}').map(colorir_valores, subset=pd.IndexSlice[:, :])
st.dataframe(styled_pivot, use_container_width=True)

# Bot√£o de download da Tabela Din√¢mica (logo abaixo da tabela)
if st.button("üì• Baixar Tabela Din√¢mica (Excel)", use_container_width=True, key="download_pivot"):
    with st.spinner("Gerando arquivo da tabela din√¢mica..."):
        # Fun√ß√£o para exportar para Excel
        def exportar_excel_pivot(df, nome_arquivo):
            from io import BytesIO
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df.to_excel(writer, index=True, sheet_name='Tabela_Dinamica')
            output.seek(0)
            return output.getvalue()
        
        excel_data_pivot = exportar_excel_pivot(df_pivot, 'KE5Z_tabela_dinamica.xlsx')
        
        # For√ßar download usando JavaScript
        import base64
        b64 = base64.b64encode(excel_data_pivot).decode()
        href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="KE5Z_tabela_dinamica.xlsx">üíæ Clique aqui para baixar a Tabela Din√¢mica</a>'
        st.markdown(href, unsafe_allow_html=True)
        st.success("‚úÖ Tabela Din√¢mica gerada! Clique no link acima para baixar.")

# Exibir o DataFrame filtrado (limitado para performance)
st.subheader("Tabela Filtrada")
display_limit = 500 if is_cloud else 2000
if len(df_filtrado) > display_limit:
    st.info(f"üìä Mostrando {display_limit:,} de {len(df_filtrado):,} registros para otimizar performance")
    df_display = df_filtrado.head(display_limit)
else:
    df_display = df_filtrado

st.dataframe(df_display, use_container_width=True)

# Bot√£o de download da Tabela Filtrada (logo abaixo da tabela)
if st.button("üì• Baixar Tabela Filtrada (Excel)", use_container_width=True, key="download_filtered"):
    with st.spinner("Gerando arquivo da tabela filtrada..."):
        # Fun√ß√£o para exportar tabela filtrada
        def exportar_excel_filtrada(df, nome_arquivo):
            from io import BytesIO
            output = BytesIO()
            with pd.ExcelWriter(output, engine='openpyxl') as writer:
                df.to_excel(writer, index=False, sheet_name='Dados_Filtrados')
            output.seek(0)
            return output.getvalue()
        
        excel_data_filtrada = exportar_excel_filtrada(df_filtrado, 'KE5Z_tabela_filtrada.xlsx')
        
        # For√ßar download usando JavaScript
        import base64
        b64 = base64.b64encode(excel_data_filtrada).decode()
        href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="KE5Z_tabela_filtrada.xlsx">üíæ Clique aqui para baixar a Tabela Filtrada</a>'
        st.markdown(href, unsafe_allow_html=True)
        st.success("‚úÖ Tabela Filtrada gerada! Clique no link acima para baixar.")

# Tabela de soma por Types (funcionalidade original restaurada)
if all(col in df_filtrado.columns for col in ['Type 05', 'Type 06', 'Type 07']):
    st.markdown("---")
    st.subheader("üìä Soma dos Valores por Type 05, Type 06 e Type 07")
    
    # Criar tabela com soma por types
    soma_por_type = (df_filtrado.groupby(['Type 05', 'Type 06', 'Type 07'])['Valor']
                     .sum().reset_index())
    
    # Adicionar linha de total
    soma_total = pd.DataFrame({
        'Type 05': ['Total'],
        'Type 06': [''],
        'Type 07': [''],
        'Valor': [soma_por_type['Valor'].sum()]
    })
    soma_por_type_completa = pd.concat([soma_por_type, soma_total], ignore_index=True)
    
    # Aplicar formata√ß√£o com cores
    def colorir_valores_type(val):
        if isinstance(val, (int, float)):
            if val < 0:
                return 'color: #e74c3c; font-weight: bold;'  # Vermelho para negativo
            elif val > 0:
                return 'color: #27ae60; font-weight: bold;'  # Verde para positivo
        return ''
    
    styled_type = soma_por_type_completa.style.format({'Valor': 'R$ {:,.2f}'}).map(
        colorir_valores_type, subset=['Valor'])
    
    st.dataframe(styled_type, use_container_width=True)
    
    # Bot√£o de download da Tabela de Soma por Types (logo abaixo da tabela)
    if st.button("üì• Baixar Soma por Types (Excel)", use_container_width=True, key="download_types"):
        with st.spinner("Gerando arquivo da soma por types..."):
            # Fun√ß√£o para exportar soma por types
            def exportar_excel_types(df, nome_arquivo):
                from io import BytesIO
                output = BytesIO()
                with pd.ExcelWriter(output, engine='openpyxl') as writer:
                    df.to_excel(writer, index=False, sheet_name='Soma_por_Types')
                output.seek(0)
                return output.getvalue()
            
            excel_data_types = exportar_excel_types(soma_por_type_completa, 'KE5Z_soma_por_types.xlsx')
            
            # For√ßar download usando JavaScript
            import base64
            b64 = base64.b64encode(excel_data_types).decode()
            href = f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="KE5Z_soma_por_types.xlsx">üíæ Clique aqui para baixar a Soma por Types</a>'
            st.markdown(href, unsafe_allow_html=True)
            st.success("‚úÖ Soma por Types gerada! Clique no link acima para baixar.")

# Footer
st.markdown("---")
st.info("üí° Dashboard KE5Z com otimiza√ß√µes de cache e mem√≥ria")

# Informa√ß√µes de funcionalidades restauradas
col1, col2, col3 = st.columns(3)
with col1:
    st.success("‚úÖ Exporta√ß√£o Excel")
with col2:
    st.success("‚úÖ Gr√°ficos Coloridos")
with col3:
    st.success("‚úÖ Tabelas com Cores")

if is_cloud:
    st.success("‚òÅÔ∏è Executando no Streamlit Cloud com otimiza√ß√µes")
else:
    st.success("üíª Executando localmente com performance m√°xima")